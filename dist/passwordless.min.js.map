{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/authenticators.ts", "../src/passwordless.ts"],
  "sourcesContent": ["/********************************\r\n     Encoding/Decoding Utils\r\n********************************/\r\n\r\nexport function toBuffer(txt :string) :ArrayBuffer {\r\n    return Uint8Array.from(txt, c => c.charCodeAt(0)).buffer\r\n}\r\n\r\nexport function parseBuffer(buffer :ArrayBuffer) :string {\r\n    return String.fromCharCode(...new Uint8Array(buffer))\r\n}\r\n\r\n\r\nexport function toBase64(buffer :ArrayBuffer) :string {\r\n    return btoa(parseBuffer(buffer))\r\n}\r\n\r\nexport function parseBase64(txt :string) :ArrayBuffer {\r\n    return toBuffer(atob(txt))\r\n}\r\n\r\nexport function parseBase64url(txt :string) :ArrayBuffer {\r\n    return parseBase64(txt.replace(/-/g, '+').replace(/_/g, '/'))\r\n}\r\n\r\n\r\nexport async function sha256(buffer :ArrayBuffer) :Promise<ArrayBuffer> {\r\n    return await window.crypto.subtle.digest('SHA-256', buffer)\r\n}\r\n\r\nexport function bufferToHex (buffer :ArrayBuffer) :string {\r\n    return [...new Uint8Array (buffer)]\r\n        .map (b => b.toString (16).padStart (2, \"0\"))\r\n        .join (\"\");\r\n}\r\n\r\n\r\nexport function concatenateBuffers(buffer1 :ArrayBuffer, buffer2  :ArrayBuffer) {\r\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\r\n    tmp.set(new Uint8Array(buffer1), 0);\r\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\r\n    return tmp;\r\n  };", "import * as authenticatorMetadata from './authenticatorMetadata.json'\r\nimport * as utils from './utils'\r\n\r\nconsole.debug(authenticatorMetadata)\r\n\r\n\r\nexport function parseAuthData(authData :ArrayBuffer) {\r\n    console.debug(authData)\r\n    let flags = new DataView(authData.slice(32,33)).getUint8(0)\r\n    console.debug(flags)\r\n\r\n    // https://w3c.github.io/webauthn/#sctn-authenticator-data\r\n    let parsed :any = {\r\n        rpIdHash: utils.toBase64(authData.slice(0,32)),\r\n            flags: {\r\n                 userPresent: !!(flags & 1),\r\n                 //reserved1: !!(flags & 2),\r\n                 userVerified: !!(flags &  4),\r\n                 backupEligibility: !!(flags & 8),\r\n                 backupState: !!(flags & 16),\r\n                 //reserved2: !!(flags & 32),\r\n                 attestedData: !!(flags & 64),\r\n                 extensionsIncluded: !!(flags & 128)\r\n            },\r\n            counter: new DataView(authData.slice(33,37)).getUint32(0, false),  // Big-Endian!\r\n    }\r\n\r\n    if(authData.byteLength > 37) {\r\n        // https://w3c.github.io/webauthn/#attested-credential-data\r\n        let credentialLength = new DataView(authData.slice(53,55)).getUint16(0, false) // Big-Endian!\r\n        parsed = {\r\n            ...parsed,\r\n            aaguid: extractAaguid(authData),\r\n            credentialId: utils.toBase64(authData.slice(55, 55+credentialLength)),\r\n            publicKey: utils.toBase64(authData.slice(55+credentialLength, authData.byteLength)) // probably breaks if extensions are invoked\r\n        }\r\n    }\r\n\r\n    return parsed\r\n}\r\n\r\nexport function extractAaguid(authData :ArrayBuffer) :string {\r\n    return formatAaguid(authData.slice(37, 53))\r\n}\r\n\r\nfunction formatAaguid(buffer :ArrayBuffer) :string {\r\n    let aaguid = utils.bufferToHex(buffer)\r\n    aaguid = aaguid.substring(0,8) + '-' + aaguid.substring(8,12) + '-' + aaguid.substring(12,16) + '-' + aaguid.substring(16,20) + '-' + aaguid.substring(20,24)\r\n    return aaguid // example: \"d41f5a69-b817-4144-a13c-9ebd6d9254d6\"\r\n}\r\n\r\nexport function resolveAuthenticatorName(authData :ArrayBuffer) :string {\r\n    const aaguid = extractAaguid(authData)\r\n    const aaguidMetadata = updatedAuthenticatorMetadata ?? authenticatorMetadata //await getAaguidMetadata()\r\n    return aaguidMetadata[aaguid]?.name\r\n}\r\n\r\nlet updatedAuthenticatorMetadata :any = null\r\n\r\n// List of AAGUIDs are encoded as JWT here: https://mds.fidoalliance.org/\r\nexport async function updateDevicesMetadata() {\r\n    // this function is rather resource intensive and time consuming\r\n    // therefore, the result is cached in local storage\r\n    const jwt = await (await fetch(\"https://mds.fidoalliance.org\")).text()\r\n\r\n    // the response is a JWT including all AAGUIDs and their metadata\r\n    console.debug(jwt)\r\n\r\n    // let us ignore the JWT verification, since this is solely for descriptive purposes, not signed data\r\n    const payload = jwt.split('.')[1].replaceAll('-', '+').replaceAll('_', '/')\r\n    const json = JSON.parse(atob(payload))\r\n    console.debug(json)\r\n\r\n    let aaguidMetadata :any = {}\r\n    for(const e of json.entries) {\r\n        if(!e.aaguid || !e.metadataStatement)\r\n            continue\r\n\r\n        aaguidMetadata[e.aaguid] = {name: e.metadataStatement.description}\r\n    }\r\n\r\n    console.debug(aaguidMetadata)\r\n    updatedAuthenticatorMetadata = aaguidMetadata\r\n}\r\n", "import * as utils from './utils'\r\nimport * as authenticators from './authenticators'\r\n\r\n/**\r\n * Returns whether passwordless authentication is available on this browser/platform or not.\r\n */\r\nexport function isAvailable() :boolean {\r\n    return !!window.PublicKeyCredential\r\n}\r\n\r\n/**\r\n * Returns whether the device itself can be used as authenticator.\r\n */\r\nexport async function isLocalAuthenticator() :Promise<boolean> {\r\n    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\r\n}\r\n\r\n\r\n\r\nexport function parseAuthenticatorData(authData :string) {\r\n    return authenticators.parseAuthData(utils.parseBase64(authData))\r\n}\r\n\r\ntype AuthType = 'auto' | 'local' | 'extern' | 'both'\r\n\r\nasync function getAuthAttachment(authType :AuthType) :Promise<AuthenticatorAttachment|undefined> {\r\n    if(authType === \"local\")\r\n        return \"platform\";\r\n    if(authType === \"extern\")\r\n        return \"cross-platform\";\r\n    if(authType === \"both\")\r\n        return undefined // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\r\n\r\n    // the default case: \"auto\", depending on device capabilities\r\n    try {\r\n        if(await isLocalAuthenticator())\r\n            return \"platform\"\r\n        else\r\n            return \"cross-platform\"\r\n    } catch(e) {\r\n        // might happen due to some security policies\r\n        // see https://w3c.github.io/webauthn/#sctn-isUserVerifyingPlatformAuthenticatorAvailable\r\n        return undefined // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\r\n    }\r\n}\r\n\r\n\r\ntype NumAlgo = -7 | -257\r\ntype NamedAlgo = 'RS256' | 'ES256'\r\n\r\nfunction getAlgoName(num :NumAlgo) :NamedAlgo {\r\n    switch(num) {\r\n        case -7: return \"ES256\"\r\n        // case -8 ignored to to its rarity\r\n        case -257: return \"RS256\"\r\n        default: throw new Error(`Unknown algorithm code: ${num}`)\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Creates a cryptographic key pair, in order to register the public key for later passwordless authentication.\r\n *\r\n * @param {string} username\r\n * @param {string} challenge A server-side randomly generated string.\r\n * @param {Object} [options] Optional parameters.\r\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\r\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\r\n * @param {'auto'|'local'|'extern'|'both'}       [options.authenticatorType='auto'] Which device to use as authenticator.\r\n *          'auto': if the local device can be used as authenticator it will be preferred. Otherwise it will prompt for an external device.\r\n *          'local': use the local device (using TouchID, FaceID, Windows Hello or PIN)\r\n *          'extern': use an external device (security key or connected phone)\r\n *          'both': prompt the user to choose between local or external device. The UI and user interaction in this case is platform specific.\r\n * @param {boolean} [attestation=false] If enabled, the device attestation and clientData will be provided as base64 encoded binary data.\r\n *                                Note that this is not available on some platforms.\r\n */\r\n//\r\nexport async function register(username :string, challenge :string, options :any) {\r\n    if(!options)\r\n        options = {}\r\n\r\n    const creationOptions :PublicKeyCredentialCreationOptions = {\r\n        challenge: utils.parseBase64url(challenge),\r\n        rp: {\r\n            id: window.location.hostname,\r\n            name: window.location.hostname\r\n        },\r\n        user: {\r\n            id: await utils.sha256(new TextEncoder().encode(username)), // ID should not be directly \"identifiable\" for privacy concerns\r\n            name: username,\r\n            displayName: username,\r\n        },\r\n        pubKeyCredParams: [\r\n            {alg: -7, type: \"public-key\"},   // ES256 (Webauthn's default algorithm)\r\n            {alg: -257, type: \"public-key\"}, // RS256 (for Windows Hello and others)\r\n        ],\r\n        timeout: options.timeout ?? 60000,\r\n        authenticatorSelection: {\r\n            userVerification: options.userVerification ?? \"required\", // Webauthn default is \"preferred\"\r\n            authenticatorAttachment: await getAuthAttachment(options.authenticatorType ?? \"auto\"),\r\n        },\r\n        attestation: \"direct\" // options.attestation ? \"direct\" : \"none\"\r\n    }\r\n\r\n    console.debug(creationOptions)\r\n    const credential = await navigator.credentials.create({publicKey: creationOptions}) as any //PublicKeyCredential\r\n    console.debug(credential)\r\n   \r\n    const response = credential.response as any //AuthenticatorAttestationResponse\r\n\r\n    return {\r\n        username: username,\r\n        challenge: challenge,\r\n        credential: {\r\n            id: credential.id,\r\n            publicKey: utils.toBase64(response.getPublicKey()),\r\n            algorithm: getAlgoName(credential.response.getPublicKeyAlgorithm())\r\n        },\r\n        authenticator: {\r\n            isLocal: (credential.authenticatorAttachment === \"platform\"),\r\n            //transport: response.getTransports()[0], // In the RFC but not implemented by browsers\r\n            aaguid: authenticators.extractAaguid(response.getAuthenticatorData()),\r\n            name: authenticators.resolveAuthenticatorName(response.getAuthenticatorData()),\r\n            attestation: options.attestation ? utils.toBase64(response.attestationObject) : null,\r\n            clientData: options.attestation ? utils.toBase64(response.clientDataJSON) : null,\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Signs a challenge using one of the provided credentials IDs in order to authenticate the user.\r\n *\r\n * @param {string[]} credentialIds The list of credential IDs that can be used for signing.\r\n * @param {string} challenge A server-side randomly generated string, the base64 encoded version will be signed.\r\n * @param {Object} [options] Optional parameters.\r\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\r\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\r\n */\r\nexport async function login(credentialIds :string[], challenge :string, options :any) {\r\n    if(!options)\r\n        options = {}\r\n\r\n    let authOptions :PublicKeyCredentialRequestOptions = {\r\n        challenge: utils.parseBase64url(challenge),\r\n        rpId: window.location.hostname,\r\n        allowCredentials: credentialIds.map(id => { return {\r\n            id: utils.parseBase64url(id),\r\n            type: 'public-key',\r\n            //transports: ['internal', 'usb', 'ble', 'nfc'],\r\n        }}),\r\n        userVerification: options.userVerification ?? \"required\",\r\n        timeout: options.timeout ?? 60000,\r\n    }\r\n\r\n    console.debug(authOptions)\r\n    let auth = await navigator.credentials.get({publicKey: authOptions}) as PublicKeyCredential\r\n    console.debug(auth)\r\n\r\n    const response = auth.response as AuthenticatorAssertionResponse\r\n\r\n    return {\r\n        credentialId: auth.id,\r\n        //userHash: utils.toBase64(response.userHandle), // unreliable, optional for authenticators\r\n        clientJson: JSON.parse(utils.parseBuffer(response.clientDataJSON)),\r\n        clientData: utils.toBase64(response.clientDataJSON),\r\n        signature: utils.toBase64(response.signature),\r\n        authenticatorJson: authenticators.parseAuthData(response.authenticatorData),\r\n        authenticatorData: utils.toBase64(response.authenticatorData)\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ntype VerifyParams = {\r\n    algorithm :'RS256' | 'ES256',\r\n    publicKey :string, // Base64 encoded\r\n    authenticatorData :string, // Base64 encoded\r\n    clientData :string, // Base64 encoded\r\n    signature :string, // Base64 encoded\r\n}\r\n\r\n// https://w3c.github.io/webauthn/#sctn-verifying-assertion\r\nexport async function verify({algorithm, publicKey, authenticatorData, clientData, signature} :VerifyParams) :Promise<boolean> {\r\n    let cryptoKey = await window.crypto.subtle.importKey(\r\n        'spki', utils.parseBase64(publicKey), {name:'RSASSA-PKCS1-v1_5', hash:'SHA-256'}, false, ['verify'])\r\n    console.debug(cryptoKey)\r\n\r\n    let clientHash = await utils.sha256( utils.parseBase64(clientData) );\r\n    console.debug(clientHash)\r\n\r\n\r\n    //let comboBuffer = concatenateBuffers(parseBase64(authenticatorData), parseBase64(clientData)) // clientHash)\r\n    let comboBuffer = utils.concatenateBuffers(utils.parseBase64(authenticatorData), clientHash)\r\n    console.debug(comboBuffer)\r\n\r\n    console.debug(utils.parseBase64(signature))\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify\r\n    let validity = await window.crypto.subtle.verify({name:'RSASSA-PKCS1-v1_5', hash:'SHA-256'}, cryptoKey, utils.parseBase64(signature), comboBuffer)\r\n\r\n    return validity\r\n}"],
  "mappings": "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",
  "names": ["toBuffer", "txt", "c", "parseBuffer", "buffer", "toBase64", "parseBase64", "parseBase64url", "sha256", "bufferToHex", "b", "concatenateBuffers", "buffer1", "buffer2", "tmp", "authenticatorMetadata_exports", "parseAuthData", "authData", "flags", "parsed", "toBase64", "credentialLength", "extractAaguid", "formatAaguid", "buffer", "aaguid", "bufferToHex", "resolveAuthenticatorName", "updatedAuthenticatorMetadata", "isAvailable", "isLocalAuthenticator", "parseAuthenticatorData", "authData", "parseAuthData", "parseBase64", "getAuthAttachment", "authType", "getAlgoName", "num", "register", "username", "challenge", "options", "creationOptions", "parseBase64url", "sha256", "credential", "response", "toBase64", "extractAaguid", "resolveAuthenticatorName", "login", "credentialIds", "authOptions", "id", "auth", "parseBuffer", "verify", "algorithm", "publicKey", "authenticatorData", "clientData", "signature", "cryptoKey", "clientHash", "comboBuffer", "concatenateBuffers"]
}
